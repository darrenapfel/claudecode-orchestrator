#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Configuration
const SCRIPT_VERSION = '5.0.0';
const OUTPUT_FILE = 'orchestrator.sh';
const SOURCE_DIR = './orchestrator-files';
const EXCLUDE_DIRS = ['.git', 'node_modules'];
const EXCLUDE_FILES = [];

// Colors for output
const colors = {
  green: '\033[0;32m',
  blue: '\033[0;34m',
  yellow: '\033[1;33m',
  red: '\033[0;31m',
  cyan: '\033[0;36m',
  purple: '\033[0;35m',
  reset: '\033[0m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Recursively find all files in a directory
function getAllFiles(dir, basePath = '') {
  const files = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const item of items) {
    const fullPath = path.join(dir, item.name);
    const relativePath = path.join(basePath, item.name);
    
    // Skip excluded directories and files
    if (EXCLUDE_DIRS.includes(item.name) || EXCLUDE_FILES.includes(item.name)) {
      continue;
    }
    
    if (item.isDirectory()) {
      files.push(...getAllFiles(fullPath, relativePath));
    } else if (item.isFile()) {
      files.push({
        path: fullPath,
        relativePath: relativePath,
        name: item.name
      });
    }
  }
  
  return files;
}

// Generate unique EOF marker for a file
function generateEOFMarker(filePath) {
  const filename = path.basename(filePath).replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
  return `${filename}_EOF`;
}

// Escape content for heredoc
function escapeContent(content) {
  // No escaping needed for single-quoted heredoc
  return content;
}

// Generate the shell script header
function generateHeader() {
  return `#!/bin/bash

# Claude Code Orchestration System Installer v${SCRIPT_VERSION}
# Version: ${SCRIPT_VERSION}
# Generated: ${new Date().toISOString()}
# 
# This script was automatically generated by build-orchestrator.js
# It deploys the complete orchestration system with all files included.
#
# Features in v5.0:
# - Task-level git commits with file isolation
# - Milestone-based development phases
# - Numbered validation cycles (validation-1, validation-2...)
# - Master reference documents (directory, git strategy)
# - Orchestrator announces all git actions in chat
# - File tracking for commit isolation
# - Integration commits separate from features
# - Honesty-first development with visible evidence
#
# Usage:
#   ./orchestrator.sh        # Interactive installation
#   ./orchestrator.sh local  # Install to current project directory
#   ./orchestrator.sh global # Install globally to ~/.claude

set -e

# Color codes for output
GREEN='\\033[0;32m'
BLUE='\\033[0;34m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
CYAN='\\033[0;36m'
PURPLE='\\033[0;35m'
NC='\\033[0m' # No Color

# Interactive installation prompt
if [ "$1" = "global" ] || [ "$1" = "local" ]; then
    INSTALL_MODE="$1"
else
    echo -e "\${BLUE}┌─────────────────────────────────────────────────────┐\${NC}"
    echo -e "\${BLUE}│        Claude Orchestration System v${SCRIPT_VERSION}            │\${NC}"
    echo -e "\${BLUE}│    Session Tracking • Evidence Linking • Quality   │\${NC}"
    echo -e "\${BLUE}│         100% Compliance • Full Traceability        │\${NC}"
    echo -e "\${BLUE}└─────────────────────────────────────────────────────┘\${NC}"
    echo ""
    echo -e "\${CYAN}✨ Complete v${SCRIPT_VERSION} System Features:\${NC}"
    echo "   📂 Milestone-based development phases with sprint tracking"
    echo "   📋 Mandatory INTERFACE.md in every task"
    echo "   🔧 Separate TECH-STACK.md requirement"
    echo "   📦 Implementation batch management"
    echo "   🔗 Git workflow with evidence linking"
    echo "   🔄 Fix cycle protocol for failures"
    echo "   📁 Enhanced directory compliance"
    echo ""
    echo "Choose installation type:"
    echo "1) Global installation (~/.claude) - Use across all projects"
    echo "2) Local installation (./.claude) - This project only"
    echo ""
    echo -n "Enter choice [1-2]: "
    read -r choice
    
    case $choice in
        1) INSTALL_MODE="global" ;;
        2) INSTALL_MODE="local" ;;
        *) echo -e "\${RED}Invalid choice. Exiting.\${NC}"; exit 1 ;;
    esac
fi

# Set installation directory based on mode
if [ "$INSTALL_MODE" = "global" ]; then
    INSTALL_DIR="$HOME/.claude"
    echo -e "\\n\${BLUE}🌐 Installing globally to ~/.claude\${NC}"
else
    INSTALL_DIR="./.claude"
    echo -e "\\n\${BLUE}📁 Installing locally to current project\${NC}"
fi

# Create directory structure
echo -e "\${GREEN}📁 Creating directory structure...\${NC}"
mkdir -p "$INSTALL_DIR"/{personas,validators,examples,preferences/tech-stacks,deployment,hooks}
mkdir -p "$INSTALL_DIR"/{architecture-templates,state-management,utilities,patterns,discovery}

# Only create .work directories for local installation
if [ "$INSTALL_MODE" = "local" ]; then
    # Create project-wide directories
    mkdir -p .work/{milestones,discovery,sprints}
    # Create project-wide foundation (created once for entire project)
    mkdir -p .work/foundation/{architecture,ux,product}
    # Create discovery structure
    mkdir -p .work/discovery/responses
    # Note: Milestone directories created at runtime by orchestrator
    # Sample structure to show pattern:
    mkdir -p .work/milestones/YYYYMMDD-sample-milestone
    mkdir -p .work/milestones/YYYYMMDD-sample-milestone/sprint-XXX/{tasks,implementation,integration,fixes}
    mkdir -p .work/milestones/YYYYMMDD-sample-milestone/sprint-XXX/validation-1/artifacts
    mkdir -p .work/milestones/YYYYMMDD-sample-milestone/sprint-XXX/fixes/cycle-1
    mkdir -p .work/milestones/YYYYMMDD-sample-milestone/sprint-XXX/validation-2/artifacts
    mkdir -p .work/milestones/YYYYMMDD-sample-milestone/sprint-XXX/tasks/YYYYMMDD-HHMM-sample-task/artifacts
fi
`;
}

// Generate file creation section
function generateFileSection(file, isSpecialFile = false) {
  const eofMarker = generateEOFMarker(file.relativePath);
  const content = fs.readFileSync(file.path, 'utf8');
  
  // Fix path handling - remove .claude/ prefix for install path
  const cleanPath = file.relativePath.startsWith('.claude/') 
    ? file.relativePath.substring(8)  // Remove '.claude/' prefix
    : file.relativePath;
    
  const installPath = isSpecialFile ? file.relativePath : `"$INSTALL_DIR/${cleanPath}"`;
  
  // Files that should not be overwritten if they exist
  const preserveFiles = [
    'PROJECT-STATE.md',
    'STATUS.md',
    'DECISIONS.md',
    'ISSUES.md',
    'TODO.md',
    'EVIDENCE.md',
    'TASK.md'
  ];
  
  const shouldPreserve = preserveFiles.some(pf => file.name === pf || file.name.endsWith(pf));
  
  let section = `\n# ${file.relativePath}\n`;
  
  if (isSpecialFile) {
    // Handle special files differently for global vs local installation
    if (file.name === 'CLAUDE.md') {
      // CLAUDE.md has special handling for both global and local
      section += `if [ "$INSTALL_MODE" = "global" ]; then\n`;
      section += `    echo -e "\${GREEN}📄 Creating claude.md in ~/.claude/...\${NC}"\n`;
      section += `    cat > "$INSTALL_DIR/claude.md" << '${eofMarker}'\n`;
      section += escapeContent(content);
      section += `\n${eofMarker}\n`;
      section += `else\n`;
      section += `    echo -e "\${GREEN}📄 Creating CLAUDE.md...\${NC}"\n`;
      section += `    cat > "CLAUDE.md" << '${eofMarker}'\n`;
      section += escapeContent(content);
      section += `\n${eofMarker}\n`;
      section += `fi\n`;
      return section;
    } else {
      // Other special files (.gitignore, CHANGELOG.md, readme.md) only for local
      section += `if [ "$INSTALL_MODE" != "global" ]; then\n`;
      if (shouldPreserve) {
        section += `    if [ ! -f "${file.name}" ]; then\n`;
        section += `        echo -e "\${GREEN}📄 Creating ${file.name}...\${NC}"\n`;
        section += `        cat > "${file.name}" << '${eofMarker}'\n`;
      } else {
        section += `    echo -e "\${GREEN}📄 Creating ${file.name}...\${NC}"\n`;
        section += `    cat > "${file.name}" << '${eofMarker}'\n`;
      }
    }
  } else {
    if (shouldPreserve) {
      section += `if [ ! -f ${installPath} ]; then\n`;
      section += `    echo -e "\${GREEN}📄 Creating ${file.relativePath}...\${NC}"\n`;
      section += `    cat > ${installPath} << '${eofMarker}'\n`;
    } else {
      section += `echo -e "\${GREEN}📄 Creating ${file.relativePath}...\${NC}"\n`;
      section += `cat > ${installPath} << '${eofMarker}'\n`;
    }
  }
  
  section += escapeContent(content);
  section += `\n${eofMarker}\n`;
  
  if (shouldPreserve && !isSpecialFile) {
    section += `else\n`;
    section += `    echo -e "\${YELLOW}⏭️  Preserving existing ${file.relativePath}\${NC}"\n`;
    section += `fi\n`;
  } else if (shouldPreserve && isSpecialFile) {
    section += `    else\n`;
    section += `        echo -e "\${YELLOW}⏭️  Preserving existing ${file.name}\${NC}"\n`;
    section += `    fi\n`;
  }
  
  if (isSpecialFile && !shouldPreserve) {
    section += `fi\n`;
  } else if (isSpecialFile && shouldPreserve) {
    section += `fi\n`;
  }
  
  return section;
}

// Generate the footer
function generateFooter(totalFiles) {
  return `
echo -e "\\n\${GREEN}✅ Installation Complete!\${NC}"
echo -e "\${BLUE}====================================================================\${NC}"
echo -e "\${CYAN}🎉 Claude Orchestration System v${SCRIPT_VERSION} (Auto-Generated) Successfully Installed\${NC}"
echo -e "\${BLUE}====================================================================\${NC}"

echo -e "\\n📁 Installation Directory: \${YELLOW}$INSTALL_DIR\${NC}"
if [ "$INSTALL_MODE" = "local" ]; then
    echo -e "📁 Working Directory: \${YELLOW}./.work/\${NC} (created in current project)"
fi

echo -e "\\n📋 Complete System Installed:"
echo -e "   \${GREEN}✅\${NC} ${totalFiles} files embedded (auto-generated from directory scan)"
echo -e "   \${GREEN}✅\${NC} All personas, architecture templates, state management"
echo -e "   \${GREEN}✅\${NC} Progress visualization utilities and examples"
echo -e "   \${GREEN}✅\${NC} Complete documentation suite and validators"
if [ "$INSTALL_MODE" = "local" ]; then
    echo -e "   \${GREEN}✅\${NC} Sample .work structure and git hooks"
fi

echo -e "\\n🆕 \${CYAN}Features in v${SCRIPT_VERSION}:\${NC}"
echo -e "   📂 Milestone directories with numbered validations"
echo -e "   📋 Every task must have INTERFACE.md"  
echo -e "   🔧 Architect creates separate TECH-STACK.md"
echo -e "   📦 Orchestrator manages implementation batches"
echo -e "   🔗 Git commits link to task evidence"
echo -e "   🔄 Structured fix cycles for validation failures"

echo -e "\\n🚀 \${YELLOW}Next Steps:\${NC}"
if [ "$INSTALL_MODE" = "global" ]; then
    echo -e "   1. \${CYAN}cd\${NC} into any project directory"
    echo -e "   2. Run \${CYAN}./orchestrator.sh local\${NC} to set up project-specific files"
    echo -e "   3. Claude will ASK before taking any action"
else
    echo -e "   1. Initialize git repository: \${CYAN}git init\${NC} (if not already done)"
    echo -e "   2. Start Claude Code in this directory"
    echo -e "   3. Make any request - Claude will ask if you want orchestration"
    echo -e "   4. Choose option 1 for parallel execution, 2 for direct handling"
fi

echo -e "\\n💡 \${YELLOW}Quick Start Examples:\${NC}"
echo -e "   \${CYAN}\\"Build a user authentication system\\"\${NC}"
echo -e "   \${CYAN}\\"Create a responsive dashboard component\\"\${NC}"
echo -e "   \${CYAN}\\"Implement real-time notifications\\"\${NC}"
echo -e "   \${CYAN}\\"Add comprehensive testing to my API\\"\${NC}"

echo -e "\\n📖 \${YELLOW}Documentation:\${NC}"
echo -e "   • Quick Reference: \${CYAN}$INSTALL_DIR/orchestrator-quick-reference.md\${NC}"
echo -e "   • Git Workflow: \${CYAN}$INSTALL_DIR/git-workflow.md\${NC}"
echo -e "   • Examples: \${CYAN}$INSTALL_DIR/examples/\${NC}"

echo -e "\\n🤖 \${PURPLE}Generated by: build-orchestrator.js at $(date)\${NC}"
echo ""
`;
}

// Main function to build the script
function buildScript() {
  log('🔧 Building orchestrator shell script automatically...', 'blue');
  
  // Check if source directory exists
  if (!fs.existsSync(SOURCE_DIR)) {
    log(`❌ Source directory '${SOURCE_DIR}' not found!`, 'red');
    return false;
  }
  
  // Get all files from orchestrator-files directory
  log('📁 Scanning orchestrator-files directory...', 'green');
  const allFiles = getAllFiles(SOURCE_DIR);
  
  // Separate special files (CLAUDE.md, gitignore) from regular files
  const specialFiles = allFiles.filter(f => 
    (f.name === 'CLAUDE.md' || 
     f.name === '.gitignore' || 
     f.name === 'CHANGELOG.md' ||
     f.name === 'readme.md') &&
    !f.relativePath.includes('/')  // Only root-level files
  );
  
  const regularFiles = allFiles.filter(f => 
    !specialFiles.includes(f) && 
    f.relativePath.startsWith('.claude/')
  );
  
  const workFiles = allFiles.filter(f => 
    f.relativePath.startsWith('.work/')
  );
  
  log(`📊 Found ${allFiles.length} total files:`, 'cyan');
  log(`   • ${specialFiles.length} special files (CLAUDE.md, etc.)`, 'yellow');
  log(`   • ${regularFiles.length} .claude/ files`, 'yellow');
  log(`   • ${workFiles.length} .work/ template files`, 'yellow');
  
  // Build the script
  log('🏗️ Generating shell script...', 'green');
  let script = generateHeader();
  
  // Add special files
  if (specialFiles.length > 0) {
    script += '\n# ===== SPECIAL FILES =====\n';
    for (const file of specialFiles) {
      script += generateFileSection(file, true);
    }
  }
  
  // Group regular files by directory
  const filesByDir = {};
  for (const file of regularFiles) {
    const dir = path.dirname(file.relativePath);
    if (!filesByDir[dir]) filesByDir[dir] = [];
    filesByDir[dir].push(file);
  }
  
  // Add regular files by category
  const categories = [
    { dir: '.claude', title: 'CORE FILES' },
    { dir: '.claude/personas', title: 'PERSONAS' },
    { dir: '.claude/discovery', title: 'DISCOVERY QUESTIONS' },
    { dir: '.claude/architecture-templates', title: 'ARCHITECTURE TEMPLATES' },
    { dir: '.claude/state-management', title: 'STATE MANAGEMENT' },
    { dir: '.claude/utilities', title: 'UTILITIES' },
    { dir: '.claude/examples', title: 'EXAMPLES' },
    { dir: '.claude/validators', title: 'VALIDATORS' },
    { dir: '.claude/patterns', title: 'PATTERNS' },
    { dir: '.claude/preferences', title: 'PREFERENCES' },
    { dir: '.claude/preferences/tech-stacks', title: 'TECH STACKS' },
    { dir: '.claude/hooks', title: 'HOOKS' }
  ];
  
  for (const category of categories) {
    const categoryFiles = filesByDir[category.dir] || [];
    if (categoryFiles.length > 0) {
      script += `\n# ===== ${category.title} =====\n`;
      script += `echo -e "\${GREEN}📂 Creating ${category.title.toLowerCase()}...\${NC}"\n`;
      
      for (const file of categoryFiles) {
        script += generateFileSection(file);
      }
    }
  }
  
  // Add .work files for local installation only
  if (workFiles.length > 0) {
    script += '\n# ===== WORK STRUCTURE (LOCAL ONLY) =====\n';
    script += 'if [ "$INSTALL_MODE" = "local" ]; then\n';
    script += '    echo -e "${GREEN}📂 Creating .work structure...${NC}"\n';
    
    for (const file of workFiles) {
      const installPath = file.relativePath;
      const eofMarker = generateEOFMarker(file.relativePath);
      const content = fs.readFileSync(file.path, 'utf8');
      
      // Files that should not be overwritten if they exist
      const preserveFiles = [
        'PROJECT-STATE.md',
        'STATUS.md',
        'DECISIONS.md',
        'ISSUES.md',
        'TODO.md',
        'EVIDENCE.md',
        'TASK.md'
      ];
      
      const shouldPreserve = preserveFiles.some(pf => file.name === pf || file.name.endsWith(pf));
      
      if (shouldPreserve) {
        script += `    if [ ! -f "${installPath}" ]; then\n`;
        script += `        echo -e "\${GREEN}📄 Creating ${installPath}...\${NC}"\n`;
        script += `        cat > ${installPath} << '${eofMarker}'\n`;
        script += escapeContent(content);
        script += `\n${eofMarker}\n`;
        script += `    else\n`;
        script += `        echo -e "\${YELLOW}⏭️  Preserving existing ${installPath}\${NC}"\n`;
        script += `    fi\n\n`;
      } else {
        script += `    cat > ${installPath} << '${eofMarker}'\n`;
        script += escapeContent(content);
        script += `\n${eofMarker}\n\n`;
      }
    }
    
    script += 'fi\n';
  }
  
  // Add footer
  script += generateFooter(allFiles.length);
  
  // Write the script
  log(`💾 Writing to ${OUTPUT_FILE}...`, 'green');
  fs.writeFileSync(OUTPUT_FILE, script);
  
  // Make executable
  try {
    fs.chmodSync(OUTPUT_FILE, 0o755);
    log('✅ Made script executable', 'green');
  } catch (error) {
    log('⚠️ Could not make script executable (try: chmod +x orchestrator-v2.5-auto.sh)', 'yellow');
  }
  
  // Validate syntax
  log('🔍 Validating script syntax...', 'blue');
  const { execSync } = require('child_process');
  try {
    execSync(`bash -n ${OUTPUT_FILE}`, { stdio: 'pipe' });
    log('✅ Script syntax is valid', 'green');
  } catch (error) {
    log('❌ Script syntax error:', 'red');
    log(error.stderr.toString(), 'red');
    return false;
  }
  
  // Summary
  log('\n🎉 Successfully generated orchestrator script!', 'cyan');
  log(`📄 File: ${OUTPUT_FILE}`, 'blue');
  log(`📏 Size: ${Math.round(fs.statSync(OUTPUT_FILE).size / 1024)}KB`, 'blue');
  log(`📁 Files embedded: ${allFiles.length}`, 'blue');
  log(`🏷️ Version: ${SCRIPT_VERSION}`, 'blue');
  
  log('\n🚀 To test the script:', 'yellow');
  log(`   ./orchestrator.sh local`, 'cyan');
  
  return true;
}

// Run if called directly
if (require.main === module) {
  const success = buildScript();
  process.exit(success ? 0 : 1);
}

module.exports = { buildScript };