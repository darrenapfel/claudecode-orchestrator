#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Configuration
const SCRIPT_VERSION = '3.3.0';
const OUTPUT_FILE = 'orchestrator.sh';
const SOURCE_DIR = './orchestrator-files';
const EXCLUDE_DIRS = ['.git', 'node_modules'];
const EXCLUDE_FILES = [];

// Colors for output
const colors = {
  green: '\033[0;32m',
  blue: '\033[0;34m',
  yellow: '\033[1;33m',
  red: '\033[0;31m',
  cyan: '\033[0;36m',
  purple: '\033[0;35m',
  reset: '\033[0m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Recursively find all files in a directory
function getAllFiles(dir, basePath = '') {
  const files = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const item of items) {
    const fullPath = path.join(dir, item.name);
    const relativePath = path.join(basePath, item.name);
    
    // Skip excluded directories and files
    if (EXCLUDE_DIRS.includes(item.name) || EXCLUDE_FILES.includes(item.name)) {
      continue;
    }
    
    if (item.isDirectory()) {
      files.push(...getAllFiles(fullPath, relativePath));
    } else if (item.isFile()) {
      files.push({
        path: fullPath,
        relativePath: relativePath,
        name: item.name
      });
    }
  }
  
  return files;
}

// Generate unique EOF marker for a file
function generateEOFMarker(filePath) {
  const filename = path.basename(filePath).replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
  return `${filename}_EOF`;
}

// Escape content for heredoc
function escapeContent(content) {
  // No escaping needed for single-quoted heredoc
  return content;
}

// Generate the shell script header
function generateHeader() {
  return `#!/bin/bash

# Claude Code Orchestration System Installer v${SCRIPT_VERSION}
# Version: ${SCRIPT_VERSION}
# Generated: ${new Date().toISOString()}
# 
# This script was automatically generated by build-orchestrator.js
# It deploys the complete orchestration system with all files included.
#
# Features in v3.3:
# - Ask-first protocol - Claude asks before taking action
# - Integration convergence validation for parallel tasks
# - 76% documentation reduction while improving clarity
# - Mandatory screenshot evidence for UI testing
# - INTERFACE.md requirements for stream contracts
# - New integration-engineer persona
# - Consolidated TASK-EXECUTION-GUIDE.md
# - Task sizing by deliverables, not time
#
# Usage:
#   ./orchestrator.sh        # Interactive installation
#   ./orchestrator.sh local  # Install to current project directory
#   ./orchestrator.sh global # Install globally to ~/.claude

set -e

# Color codes for output
GREEN='\\033[0;32m'
BLUE='\\033[0;34m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
CYAN='\\033[0;36m'
PURPLE='\\033[0;35m'
NC='\\033[0m' # No Color

# Interactive installation prompt
if [ "$1" = "global" ] || [ "$1" = "local" ]; then
    INSTALL_MODE="$1"
else
    echo -e "\${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\${NC}"
    echo -e "\${BLUE}â”‚        Claude Orchestration System v${SCRIPT_VERSION}            â”‚\${NC}"
    echo -e "\${BLUE}â”‚      Ask First â€¢ Validate Always â€¢ Integrate       â”‚\${NC}"
    echo -e "\${BLUE}â”‚         76% Smaller â€¢ 100% More Accurate           â”‚\${NC}"
    echo -e "\${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\${NC}"
    echo ""
    echo -e "\${CYAN}âœ¨ Complete v${SCRIPT_VERSION} System Features:\${NC}"
    echo "   ðŸš€ Ask-first protocol - Claude asks before acting"
    echo "   ðŸ”— Integration validation for parallel tasks"
    echo "   ðŸ“ 76% smaller docs with better clarity"
    echo "   ðŸ“¸ Mandatory screenshots for UI testing"
    echo "   ðŸ“‹ INTERFACE.md for stream contracts"
    echo "   ðŸ§© New integration-engineer persona"
    echo "   ðŸ“– Consolidated task execution guide"
    echo ""
    echo "Choose installation type:"
    echo "1) Global installation (~/.claude) - Use across all projects"
    echo "2) Local installation (./.claude) - This project only"
    echo ""
    echo -n "Enter choice [1-2]: "
    read -r choice
    
    case $choice in
        1) INSTALL_MODE="global" ;;
        2) INSTALL_MODE="local" ;;
        *) echo -e "\${RED}Invalid choice. Exiting.\${NC}"; exit 1 ;;
    esac
fi

# Set installation directory based on mode
if [ "$INSTALL_MODE" = "global" ]; then
    INSTALL_DIR="$HOME/.claude"
    echo -e "\\n\${BLUE}ðŸŒ Installing globally to ~/.claude\${NC}"
else
    INSTALL_DIR="./.claude"
    echo -e "\\n\${BLUE}ðŸ“ Installing locally to current project\${NC}"
fi

# Create directory structure
echo -e "\${GREEN}ðŸ“ Creating directory structure...\${NC}"
mkdir -p "$INSTALL_DIR"/{personas,validators,examples,preferences/tech-stacks,deployment,hooks}
mkdir -p "$INSTALL_DIR"/{architecture-templates,state-management,utilities,patterns}

# Only create .work directories for local installation
if [ "$INSTALL_MODE" = "local" ]; then
    mkdir -p .work/{tasks/sample-task/streams/{implementation,testing,security,architecture},sessions,Status,convergence}
    mkdir -p .work/tasks/sample-task/streams/{implementation,testing,security}/evidence
    mkdir -p .work/reports
fi
`;
}

// Generate file creation section
function generateFileSection(file, isSpecialFile = false) {
  const eofMarker = generateEOFMarker(file.relativePath);
  const content = fs.readFileSync(file.path, 'utf8');
  
  // Fix path handling - remove .claude/ prefix for install path
  const cleanPath = file.relativePath.startsWith('.claude/') 
    ? file.relativePath.substring(8)  // Remove '.claude/' prefix
    : file.relativePath;
    
  const installPath = isSpecialFile ? file.relativePath : `"$INSTALL_DIR/${cleanPath}"`;
  
  // Files that should not be overwritten if they exist
  const preserveFiles = [
    'PROJECT-STATE.md',
    'STATUS.md',
    'DECISIONS.md',
    'ISSUES.md',
    'TODO.md',
    'EVIDENCE.md',
    'TASK.md'
  ];
  
  const shouldPreserve = preserveFiles.some(pf => file.name === pf || file.name.endsWith(pf));
  
  let section = `\n# ${file.relativePath}\n`;
  
  if (isSpecialFile) {
    section += `if [ "$INSTALL_MODE" != "global" ]; then\n`;
    if (shouldPreserve) {
      section += `    if [ ! -f "${file.name}" ]; then\n`;
      section += `        echo -e "\${GREEN}ðŸ“„ Creating ${file.name}...\${NC}"\n`;
      section += `        cat > "${file.name}" << '${eofMarker}'\n`;
    } else {
      section += `    echo -e "\${GREEN}ðŸ“„ Creating ${file.name}...\${NC}"\n`;
      section += `    cat > "${file.name}" << '${eofMarker}'\n`;
    }
  } else {
    if (shouldPreserve) {
      section += `if [ ! -f ${installPath} ]; then\n`;
      section += `    echo -e "\${GREEN}ðŸ“„ Creating ${file.relativePath}...\${NC}"\n`;
      section += `    cat > ${installPath} << '${eofMarker}'\n`;
    } else {
      section += `echo -e "\${GREEN}ðŸ“„ Creating ${file.relativePath}...\${NC}"\n`;
      section += `cat > ${installPath} << '${eofMarker}'\n`;
    }
  }
  
  section += escapeContent(content);
  section += `\n${eofMarker}\n`;
  
  if (shouldPreserve && !isSpecialFile) {
    section += `else\n`;
    section += `    echo -e "\${YELLOW}â­ï¸  Preserving existing ${file.relativePath}\${NC}"\n`;
    section += `fi\n`;
  } else if (shouldPreserve && isSpecialFile) {
    section += `    else\n`;
    section += `        echo -e "\${YELLOW}â­ï¸  Preserving existing ${file.name}\${NC}"\n`;
    section += `    fi\n`;
  }
  
  if (isSpecialFile && !shouldPreserve) {
    section += `fi\n`;
  } else if (isSpecialFile && shouldPreserve) {
    section += `fi\n`;
  }
  
  return section;
}

// Generate the footer
function generateFooter(totalFiles) {
  return `
echo -e "\\n\${GREEN}âœ… Installation Complete!\${NC}"
echo -e "\${BLUE}====================================================================\${NC}"
echo -e "\${CYAN}ðŸŽ‰ Claude Orchestration System v${SCRIPT_VERSION} (Auto-Generated) Successfully Installed\${NC}"
echo -e "\${BLUE}====================================================================\${NC}"

echo -e "\\nðŸ“ Installation Directory: \${YELLOW}$INSTALL_DIR\${NC}"
if [ "$INSTALL_MODE" = "local" ]; then
    echo -e "ðŸ“ Working Directory: \${YELLOW}./.work/\${NC} (created in current project)"
fi

echo -e "\\nðŸ“‹ Complete System Installed:"
echo -e "   \${GREEN}âœ…\${NC} ${totalFiles} files embedded (auto-generated from directory scan)"
echo -e "   \${GREEN}âœ…\${NC} All personas, architecture templates, state management"
echo -e "   \${GREEN}âœ…\${NC} Progress visualization utilities and examples"
echo -e "   \${GREEN}âœ…\${NC} Complete documentation suite and validators"
if [ "$INSTALL_MODE" = "local" ]; then
    echo -e "   \${GREEN}âœ…\${NC} Sample .work structure and git hooks"
fi

echo -e "\\nðŸ†• \${CYAN}Features in v${SCRIPT_VERSION}:\${NC}"
echo -e "   ðŸš€ Ask-first protocol - no more trigger confusion"
echo -e "   ðŸ”— Integration validation catches parallel conflicts"
echo -e "   ðŸ“ 76% documentation reduction, better clarity"
echo -e "   ðŸ“¸ Mandatory screenshot evidence for UI"
echo -e "   ðŸ“‹ INTERFACE.md tracks stream contracts"
echo -e "   ðŸ§© 12 streamlined personas (avg 90% smaller)"

echo -e "\\nðŸš€ \${YELLOW}Next Steps:\${NC}"
if [ "$INSTALL_MODE" = "global" ]; then
    echo -e "   1. \${CYAN}cd\${NC} into any project directory"
    echo -e "   2. Run \${CYAN}./orchestrator.sh local\${NC} to set up project-specific files"
    echo -e "   3. Claude will ASK before taking any action"
else
    echo -e "   1. Initialize git repository: \${CYAN}git init\${NC} (if not already done)"
    echo -e "   2. Start Claude Code in this directory"
    echo -e "   3. Make any request - Claude will ask if you want orchestration"
    echo -e "   4. Choose option 1 for parallel execution, 2 for direct handling"
fi

echo -e "\\nðŸ’¡ \${YELLOW}Quick Start Examples:\${NC}"
echo -e "   \${CYAN}\\"Build a user authentication system\\"\${NC}"
echo -e "   \${CYAN}\\"Create a responsive dashboard component\\"\${NC}"
echo -e "   \${CYAN}\\"Implement real-time notifications\\"\${NC}"
echo -e "   \${CYAN}\\"Add comprehensive testing to my API\\"\${NC}"

echo -e "\\nðŸ“– \${YELLOW}Documentation:\${NC}"
echo -e "   â€¢ Quick Reference: \${CYAN}$INSTALL_DIR/orchestrator-quick-reference.md\${NC}"
echo -e "   â€¢ Git Workflow: \${CYAN}$INSTALL_DIR/git-workflow.md\${NC}"
echo -e "   â€¢ Examples: \${CYAN}$INSTALL_DIR/examples/\${NC}"

echo -e "\\nðŸ¤– \${PURPLE}Generated by: build-orchestrator.js at $(date)\${NC}"
echo ""
`;
}

// Main function to build the script
function buildScript() {
  log('ðŸ”§ Building orchestrator shell script automatically...', 'blue');
  
  // Check if source directory exists
  if (!fs.existsSync(SOURCE_DIR)) {
    log(`âŒ Source directory '${SOURCE_DIR}' not found!`, 'red');
    return false;
  }
  
  // Get all files from orchestrator-files directory
  log('ðŸ“ Scanning orchestrator-files directory...', 'green');
  const allFiles = getAllFiles(SOURCE_DIR);
  
  // Separate special files (CLAUDE.md, gitignore) from regular files
  const specialFiles = allFiles.filter(f => 
    (f.name === 'CLAUDE.md' || 
     f.name === '.gitignore' || 
     f.name === 'CHANGELOG.md' ||
     f.name === 'readme.md') &&
    !f.relativePath.includes('/')  // Only root-level files
  );
  
  const regularFiles = allFiles.filter(f => 
    !specialFiles.includes(f) && 
    f.relativePath.startsWith('.claude/')
  );
  
  const workFiles = allFiles.filter(f => 
    f.relativePath.startsWith('.work/')
  );
  
  log(`ðŸ“Š Found ${allFiles.length} total files:`, 'cyan');
  log(`   â€¢ ${specialFiles.length} special files (CLAUDE.md, etc.)`, 'yellow');
  log(`   â€¢ ${regularFiles.length} .claude/ files`, 'yellow');
  log(`   â€¢ ${workFiles.length} .work/ template files`, 'yellow');
  
  // Build the script
  log('ðŸ—ï¸ Generating shell script...', 'green');
  let script = generateHeader();
  
  // Add special files
  if (specialFiles.length > 0) {
    script += '\n# ===== SPECIAL FILES =====\n';
    for (const file of specialFiles) {
      script += generateFileSection(file, true);
    }
  }
  
  // Group regular files by directory
  const filesByDir = {};
  for (const file of regularFiles) {
    const dir = path.dirname(file.relativePath);
    if (!filesByDir[dir]) filesByDir[dir] = [];
    filesByDir[dir].push(file);
  }
  
  // Add regular files by category
  const categories = [
    { dir: '.claude', title: 'CORE FILES' },
    { dir: '.claude/personas', title: 'PERSONAS' },
    { dir: '.claude/architecture-templates', title: 'ARCHITECTURE TEMPLATES' },
    { dir: '.claude/state-management', title: 'STATE MANAGEMENT' },
    { dir: '.claude/utilities', title: 'UTILITIES' },
    { dir: '.claude/examples', title: 'EXAMPLES' },
    { dir: '.claude/validators', title: 'VALIDATORS' },
    { dir: '.claude/patterns', title: 'PATTERNS' },
    { dir: '.claude/preferences', title: 'PREFERENCES' },
    { dir: '.claude/preferences/tech-stacks', title: 'TECH STACKS' },
    { dir: '.claude/hooks', title: 'HOOKS' }
  ];
  
  for (const category of categories) {
    const categoryFiles = filesByDir[category.dir] || [];
    if (categoryFiles.length > 0) {
      script += `\n# ===== ${category.title} =====\n`;
      script += `echo -e "\${GREEN}ðŸ“‚ Creating ${category.title.toLowerCase()}...\${NC}"\n`;
      
      for (const file of categoryFiles) {
        script += generateFileSection(file);
      }
    }
  }
  
  // Add .work files for local installation only
  if (workFiles.length > 0) {
    script += '\n# ===== WORK STRUCTURE (LOCAL ONLY) =====\n';
    script += 'if [ "$INSTALL_MODE" = "local" ]; then\n';
    script += '    echo -e "${GREEN}ðŸ“‚ Creating .work structure...${NC}"\n';
    
    for (const file of workFiles) {
      const installPath = file.relativePath;
      const eofMarker = generateEOFMarker(file.relativePath);
      const content = fs.readFileSync(file.path, 'utf8');
      
      // Files that should not be overwritten if they exist
      const preserveFiles = [
        'PROJECT-STATE.md',
        'STATUS.md',
        'DECISIONS.md',
        'ISSUES.md',
        'TODO.md',
        'EVIDENCE.md',
        'TASK.md'
      ];
      
      const shouldPreserve = preserveFiles.some(pf => file.name === pf || file.name.endsWith(pf));
      
      if (shouldPreserve) {
        script += `    if [ ! -f "${installPath}" ]; then\n`;
        script += `        echo -e "\${GREEN}ðŸ“„ Creating ${installPath}...\${NC}"\n`;
        script += `        cat > ${installPath} << '${eofMarker}'\n`;
        script += escapeContent(content);
        script += `\n${eofMarker}\n`;
        script += `    else\n`;
        script += `        echo -e "\${YELLOW}â­ï¸  Preserving existing ${installPath}\${NC}"\n`;
        script += `    fi\n\n`;
      } else {
        script += `    cat > ${installPath} << '${eofMarker}'\n`;
        script += escapeContent(content);
        script += `\n${eofMarker}\n\n`;
      }
    }
    
    script += 'fi\n';
  }
  
  // Add footer
  script += generateFooter(allFiles.length);
  
  // Write the script
  log(`ðŸ’¾ Writing to ${OUTPUT_FILE}...`, 'green');
  fs.writeFileSync(OUTPUT_FILE, script);
  
  // Make executable
  try {
    fs.chmodSync(OUTPUT_FILE, 0o755);
    log('âœ… Made script executable', 'green');
  } catch (error) {
    log('âš ï¸ Could not make script executable (try: chmod +x orchestrator-v2.5-auto.sh)', 'yellow');
  }
  
  // Validate syntax
  log('ðŸ” Validating script syntax...', 'blue');
  const { execSync } = require('child_process');
  try {
    execSync(`bash -n ${OUTPUT_FILE}`, { stdio: 'pipe' });
    log('âœ… Script syntax is valid', 'green');
  } catch (error) {
    log('âŒ Script syntax error:', 'red');
    log(error.stderr.toString(), 'red');
    return false;
  }
  
  // Summary
  log('\nðŸŽ‰ Successfully generated orchestrator script!', 'cyan');
  log(`ðŸ“„ File: ${OUTPUT_FILE}`, 'blue');
  log(`ðŸ“ Size: ${Math.round(fs.statSync(OUTPUT_FILE).size / 1024)}KB`, 'blue');
  log(`ðŸ“ Files embedded: ${allFiles.length}`, 'blue');
  log(`ðŸ·ï¸ Version: ${SCRIPT_VERSION}`, 'blue');
  
  log('\nðŸš€ To test the script:', 'yellow');
  log(`   ./orchestrator.sh local`, 'cyan');
  
  return true;
}

// Run if called directly
if (require.main === module) {
  const success = buildScript();
  process.exit(success ? 0 : 1);
}

module.exports = { buildScript };